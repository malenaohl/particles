<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title> Particle Simulation </title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <!-- Include Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Perlin Noise Implementation
        (function() {
            var perlin = {};
            perlin.noise = (function() {
                var permutation = [151,160,137,91,90,15,
                131,13,201,95,96,53,194,233,7,225,140,36,103,
                30,69,142,8,99,37,240,21,10,23,190, 6,148,247,
                120,234,75,0,26,197,62,94,252,219,203,117,35,
                11,32,57,177,33,88,237,149,56,87,174,20,125,
                136,171,168, 68,175,74,165,71,134,139,48,27,
                166,77,146,158,231,83,111,229,122,60,211,133,
                230,220,105,92,41,55,46,245,40,244,102,143,
                54, 65,25,63,161, 1,216,80,73,209,76,132,
                187,208, 89,18,169,200,196,135,130,116,188,
                159,86,164,100,109,198,173,186, 3,64,52,217,
                226,250,124,123,5,202,38,147,118,126,255,82,
                85,212,207,206,59,227,47,16,58,17,182,189,
                28,42,223,183,170,213,119,248,152, 2,44,154,
                163, 70,221,153,101,155,167, 43,172,9,
                129,22,39,253, 19,98,108,110,79,113,224,232,
                178,185, 112,104,218,246,97,228,251,34,242,
                193,238,210,144,12,191,179,162,241, 81,51,
                145,235,249,14,239,107,49,192,214, 31,181,
                199,106,157,184, 84,204,176,115,121,50,45,
                127, 4,150,254,138,236,205,93,222,114,67,
                29,24,72,243,141,128,195,78,66,215,61,156,
                180];

                var p = new Array(512);
                for (var i = 0; i < 256; i++) {
                    p[256 + i] = p[i] = permutation[i];
                }

                function fade(t) {
                    return t * t * t * (t * (t * 6 - 15) + 10);
                }

                function lerp(t, a, b) {
                    return a + t * (b - a);
                }

                function grad(hash, x, y, z) {
                    var h = hash & 15;
                    var u = h < 8 ? x : y,
                        v = h < 4 ? y : h === 12 || h === 14 ? x : z;
                    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
                }

                return function(x, y, z) {
                    y = y || 0;
                    z = z || 0;

                    var X = Math.floor(x) & 255,
                        Y = Math.floor(y) & 255,
                        Z = Math.floor(z) & 255;

                    x -= Math.floor(x);
                    y -= Math.floor(y);
                    z -= Math.floor(z);

                    var u = fade(x),
                        v = fade(y),
                        w = fade(z);

                    var A = p[X] + Y,
                        AA = p[A] + Z,
                        AB = p[A + 1] + Z,
                        B = p[X + 1] + Y,
                        BA = p[B] + Z,
                        BB = p[B + 1] + Z;

                    return lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),
                                    grad(p[BA], x - 1, y, z)),
                                lerp(u, grad(p[AB], x, y - 1, z),
                                    grad(p[BB], x - 1, y - 1, z))),
                            lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1),
                                    grad(p[BA + 1], x - 1, y, z - 1)),
                                lerp(u, grad(p[AB + 1], x, y - 1, z - 1),
                                    grad(p[BB + 1], x - 1, y - 1, z - 1))));
                };
            })();

            window.perlin = perlin;
        })();

        // Main Script
        // General Setup
        const container = document.getElementById('container');
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // Camera Setup
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 60, 150);

        // Scene Setup
        const scene = new THREE.Scene();

        // Particle System Setup
        const particleCount = 10000;
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const xPositions = new Float32Array(particleCount);
        const zPositions = new Float32Array(particleCount);
        const waveYPositions = new Float32Array(particleCount);
        const mountainYPositions = new Float32Array(particleCount);
        const spherePositions = new Float32Array(particleCount * 3);

        // Initialize Particles in a Circular Plane (Wave-like pattern)
        function generateInitialWave() {
            const radius = 200; // Radius of the circular plane
            for (let i = 0; i < particleCount; i++) {
                // Generate random angle and distance within the circle
                const theta = Math.random() * 2 * Math.PI;
                const r = radius * Math.sqrt(Math.random()); // Square root for uniform distribution
                const x = r * Math.cos(theta);
                const z = r * Math.sin(theta);
                const y = Math.sin(0.1 * x) * Math.cos(0.1 * z) * 5;

                xPositions[i] = x;
                zPositions[i] = z;
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                waveYPositions[i] = y;
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        }

        generateInitialWave();

        const particleMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
        const particleSystem = new THREE.Points(particlesGeometry, particleMaterial);
        scene.add(particleSystem);

        // Generate Mountain Shape with Perlin Noise
        function generateMountain() {
            const maxHeight = 80;
            const sigma = 50;
            const noiseScale = 0.03;

            for (let i = 0; i < particleCount; i++) {
                const x = xPositions[i];
                const z = zPositions[i];
                const radius = Math.sqrt(x * x + z * z);

                // Gaussian function for radial height
                const radialHeight = Math.exp(- (radius * radius) / (2 * sigma * sigma)) * maxHeight;

                // Perlin noise for terrain variation
                const noiseValue = perlin.noise(x * noiseScale, z * noiseScale, 0);

                // Combine radial height and noise
                const y = radialHeight + noiseValue * 30;

                mountainYPositions[i] = y;
            }
        }

        // Generate Sphere Shape
        function generateSphere(radius) {
            for (let i = 0; i < particleCount; i++) {
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = 2 * Math.PI * Math.random();
                const randomRadius = radius + ((Math.random() - 0.5) * 5);
                const x = randomRadius * Math.sin(phi) * Math.cos(theta);
                const y = randomRadius * Math.cos(phi);
                const z = randomRadius * Math.sin(phi) * Math.sin(theta);

                spherePositions[i * 3] = x;
                spherePositions[i * 3 + 1] = y;
                spherePositions[i * 3 + 2] = z;
            }
        }

        // State Management
        let currentMode = 'wave';
        let isRotatingSphere = false;
        let isTransitioning = false;
        let transitionStartTime = 0;
        let transitionDuration = 5000; // milliseconds
        let transitionFromPositions = null;
        let transitionToPositions = null;
        let particleDelays = null; // For per-particle delays

        function transitionToSphere() {
            currentMode = 'sphere';
            generateSphere(50);
            startTransition(spherePositions);

            // Start rotating slightly before the sphere is fully formed
            setTimeout(() => {
                startRotatingSphere();
            }, 4000); // Start rotating after 4 seconds

            // Transition to mountain after holding the sphere for a while
            setTimeout(() => {
                transitionToMountain();
            }, 8000 + 5000); // 8000ms hold + 5000ms transition duration
        }

        function transitionToMountain() {
            currentMode = 'mountain';
            generateMountain();
            const targetPositions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                targetPositions[i3] = xPositions[i];
                targetPositions[i3 + 1] = mountainYPositions[i];
                targetPositions[i3 + 2] = zPositions[i];
            }
            startTransition(targetPositions);

            // Transition to waves after holding the mountain for a while
            setTimeout(() => {
                transitionToWave();
            }, 8000 + 5000); // 8000ms hold + 5000ms transition duration
        }

        function transitionToWave() {
            currentMode = 'wave';
            const targetPositions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                targetPositions[i3] = xPositions[i];
                targetPositions[i3 + 1] = waveYPositions[i];
                targetPositions[i3 + 2] = zPositions[i];
            }
            // Compute per-particle delays based on Y positions (lower particles start moving first)
            const yPositions = mountainYPositions;
            let minY = Infinity, maxY = -Infinity;
            for (let i = 0; i < particleCount; i++) {
                if (yPositions[i] < minY) minY = yPositions[i];
                if (yPositions[i] > maxY) maxY = yPositions[i];
            }
            const maxDelay = 2000; // milliseconds
            particleDelays = new Float32Array(particleCount);
            for (let i = 0; i < particleCount; i++) {
                const normalizedY = (yPositions[i] - minY) / (maxY - minY);
                // Reverse the delays so lower particles start moving first
                const delay = normalizedY * maxDelay;
                particleDelays[i] = delay;
            }
            startTransition(targetPositions, true);

            // Stop rotating after the transition is complete
            setTimeout(() => {
                stopRotatingSphere();
            }, transitionDuration + maxDelay);
        }

        function startTransition(targetPositionsArray, useDelays = false) {
            isTransitioning = true;
            transitionStartTime = Date.now();
            transitionFromPositions = new Float32Array(particlesGeometry.attributes.position.array);
            transitionToPositions = targetPositionsArray;
            if (!useDelays) {
                particleDelays = null;
            }
        }

        // Function to update wave motion for particles in wave mode
        function updateWaveMotion(time, positionsArray) {
            for (let i = 0; i < particleCount; i++) {
                const x = xPositions[i];
                const z = zPositions[i];
                // More organic wave function
                const y =
                    Math.sin(0.02 * x + time * 0.3) * 2 +
                    Math.cos(0.015 * z + time * 0.2) * 2 +
                    Math.sin(0.05 * (x + z) + time * 0.5) * 1;
                positionsArray[i * 3 + 1] = y;
            }
        }

        // Animation Loop
        let previousTime = 0;

        function animate() {
            requestAnimationFrame(animate);
            const currentTime = Date.now();
            const deltaTime = currentTime - (previousTime || currentTime);
            previousTime = currentTime;

            const time = currentTime * 0.001;

            if (isTransitioning) {
                const elapsedTime = currentTime - transitionStartTime;
                let t = Math.min(elapsedTime / transitionDuration, 1); // progress from 0 to 1

                const position = particlesGeometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    let localT = t;
                    if (particleDelays) {
                        const delay = particleDelays[i];
                        localT = Math.min(Math.max((elapsedTime - delay) / transitionDuration, 0), 1);
                    }
                    // Easing function for smoother movement
                    localT = localT * localT * (3 - 2 * localT); // Smoothstep easing

                    position[i3] = transitionFromPositions[i3] + (transitionToPositions[i3] - transitionFromPositions[i3]) * localT;
                    position[i3 + 1] = transitionFromPositions[i3 + 1] + (transitionToPositions[i3 + 1] - transitionFromPositions[i3 + 1]) * localT;
                    position[i3 + 2] = transitionFromPositions[i3 + 2] + (transitionToPositions[i3 + 2] - transitionFromPositions[i3 + 2]) * localT;

                    // Apply wave motion to particles that have completed their transition during mountain to wave transition
                    if (currentMode === 'wave' && particleDelays && (elapsedTime - particleDelays[i]) >= transitionDuration) {
                        const x = xPositions[i];
                        const z = zPositions[i];
                        // Apply wave motion
                        const y =
                            Math.sin(0.02 * x + time * 0.3) * 2 +
                            Math.cos(0.015 * z + time * 0.2) * 2 +
                            Math.sin(0.05 * (x + z) + time * 0.5) * 1;
                        position[i3 + 1] = y;
                    }
                }
                particlesGeometry.attributes.position.needsUpdate = true;

                if (t >= 1 && (!particleDelays || elapsedTime >= transitionDuration + Math.max(...particleDelays))) {
                    isTransitioning = false;
                    particleDelays = null;
                }
            } else {
                if (currentMode === 'wave') {
                    const position = particlesGeometry.attributes.position.array;
                    updateWaveMotion(currentTime * 0.001, position);
                    particlesGeometry.attributes.position.needsUpdate = true;
                }
            }

            if (isRotatingSphere) {
                particleSystem.rotation.y += 0.0025; // Rotate the particles for better visuals
            }

            renderer.render(scene, camera);
        }

        function startRotatingSphere() {
            isRotatingSphere = true;
        }

        function stopRotatingSphere() {
            isRotatingSphere = false;
            particleSystem.rotation.y = 0; // Reset rotation
        }

        // Start the animation loop and initial transition
        animate();
        setTimeout(transitionToSphere, 8000); // Start transition after initial wave

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
